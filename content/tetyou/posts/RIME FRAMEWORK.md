---
title: RIME FRAMEWORK
date: 2024-10-10
categories: ['CORE']
draft: false
---

​	When did I want to develop a game framework? I think it was during my repeated attempts to develop games. Whenever the code exceeded 10,000 lines, I began to feel the difficulty of development. However, I am quite stubborn; I either create a framework myself or choose not to use one at all. After completing the first version of "Hippocampus Slices," I realized that developing a game without a framework would lead to chaos. The various code dependencies within the "Hippocampus Slices" project sometimes made it difficult to make sense of code from just a week ago, resembling a disordered epoch with no rules. In our world, everything follows certain rules, and simulating a world requires creating an orderly system that is simple and clear. At the beginning of the universe, it was two high-speed particles colliding that gave rise to everything.

After "Hippocampus Slices," I created a "Universal Side-Scrolling Game Level Editor" and simultaneously wrote a state machine framework based on Unity's own Animator architecture, dividing it into Main and Additive states. This allowed me to switch Main states freely and add or remove Additive states at will. However, the state machine I designed at that time was too rigid, strictly adhering to design pattern principles. Ultimately, the overall architecture was not problematic, but writing new features was very painful, and the cost of creating a new state was enormous. After my graduation defense, I lost interest in this project, partly because completing an editor that could support cinematic levels was too difficult. The current editor was only at a basic level, and the workload ahead would be immense. I realized that my idea of creating an editor before finishing the game was very hard to achieve. Supporting just a creative workshop was already sufficient, but to sustain the entire main storyline of the game was far from enough. Another reason was that this project was tightly bound to the state machine framework I had written, like being stuck in a quagmire, making it hard to escape. What did I gain from this development process? I validated that my understanding of Mao Xingyun's design pattern concepts was correct and feasible, but I also realized that I still had much to learn. From the framework I wrote, it was very immature and not ready for development use.

After graduation, I joined a game company. Although the games produced were quite poor, it is undeniable that my growth during that time was rapid. I learned some systematic design concepts, such as a navigation system capable of managing hundreds of UI panels, as well as design methods and naming conventions for various tools. Meanwhile, I would also decompile some projects at night, such as "Monster Expedition." This brought my development skills close to a semi-professional level, and of course, I have some basis for this self-assessment. These experiences laid the foundation for the framework I am about to write.

After being unable to tolerate making poor games and the exhausting overtime, I chose to resign. Before resigning, I found a new position, which was Unity App development for the Vision - Pro platform, the job I was doing while writing this article. Of course, if you are reading this article later, I may no longer be doing this. This job was excellent and provided me with a lot of time and energy for self-improvement. During this period, I was responsible for the main parts of the client program for the project. After completing various tools to improve productivity, my coding skills reached unprecedented heights. One day, I found an open-source indie game project called "Slider" on GitHub, so I cloned it locally for research. I discovered that its code was so beautifully organized, even better than the code from my previous company, resembling a work of art. After reviewing the overall architecture of "Slider," I also had the idea of writing a game code framework.

The various reasons mentioned earlier led to the current outcome: I want to create a lightweight game development framework called "Rime Framework." This name is not arbitrary; when I open-sourced the "Universal Side-Scrolling Game Level Editor," my friend Mors suggested I give it a simple yet unique name. After considering countless names, I thought of the line "霧凇沆砀，天與雲與山與水，上下一白" from "Viewing Snow at the Lake Pavilion," which perfectly matched my state of mind at the time. Thus, I used "rime" to represent my yearning for a certain state of mind, leading to this name. The "Rime Framework" is lightweight, like the white frost on rime, covering and decorating the objects beneath it with purity and sanctity.

The design philosophy of the framework follows the concept of yin and yang in the Book of Changes. Controls and States are complementary, managing all game inputs and states, while Cycles and Pools are also complementary, managing all lifecycles and pools in the game. Currently, the foundation of the framework has taken shape, and after testing, it has proven to be very simple and easy to use. I will open-source it later to give back to the GitHub community.

While writing this article, I occasionally fall into a nihilistic mood. A few days ago, the Nobel Prize in Physics was awarded to the father of deep learning, as if the era of human research in natural sciences is coming to an end. The progress of general large language models is accelerating, making me wonder if writing code still holds significance. At least at this moment, it is meaningful. The act of writing this article at this point in time, in front of this computer, is significant. Although in five years, the profession of programmer may no longer exist, seizing the present is a way to combat nihilism, right? I call myself a designer at the end of the century.

<audio controls autoplay>
  <source src="/audios/Dreiton_1.mp3" type="audio/mpeg">
  Your browser does not support the audio tag.
</audio>
